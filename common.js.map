{"version":3,"file":"common.js","mappings":"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","names":["DesksStateService","AsyncHandler","new_desk_count","this","_new_desks","getValue","length","constructor","_org","_dialog","super","BehaviorSubject","asObservable","_loading","_filters","pipe","debounceTime","switchMap","filters","zones","includes","listChildMetadata","building","id","name","map","m","i","metadata","desks","details","reduce","c","showMetadata","catchError","_","list","Array","sort","a","b","localeCompare","_desks","Desk","qr_code","shareReplay","next","date","Date","filter","z","levelsForBuilding","queryBookings","period_start","Math","floor","startOfDay","valueOf","period_end","endOfDay","type","join","include_checked_out","_desk_bookings","Booking","extension_data","checkin_qr_code","generateQRCode","encodeURIComponent","asset_id","setFilters","lvl","startPolling","delay","interval","stopPolling","clearInterval","addDesks","concat","clearNewDesks","checkinDesk","desk","checkinBooking","toPromise","catch","notifyError","notifySuccess","user_name","approveDesk","approveBooking","format","rejectDesk","rejectBooking","giveAccess","success","saveBooking","access","_this","rejectAllDesks","_this2","notifyInfo","resp","openConfirmModal","title","content","icon","class","reason","loading","Promise","all","close","_angular_core__WEBPACK_IMPORTED_MODULE_15__","factory","DesksService","bookDesk","host","attendees","error_on_host","currentUser","level","levelWithID","zone","ref","open","DeskQuestionsModalComponent","race","componentInstance","event","first","afterClosed","DeskConfirmModalComponent","data","can_set_date","getUnixTime","d","user_email","toLowerCase","email","users","idx","makeDeskBooking","for_user","location","parent_id","booking_data","booking_start","user_id","booking_end","asset_name","description","booking_type","map_id","groups","core"],"sourceRoot":"webpack:///","sources":["./apps/concierge/src/app/desks/desks-state.service.ts","./libs/bookings/src/lib/desk.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { MatDialog } from '@angular/material/dialog';\nimport { listChildMetadata, showMetadata } from '@placeos/ts-client';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport {\n    catchError,\n    debounceTime,\n    map,\n    shareReplay,\n    switchMap,\n} from 'rxjs/operators';\nimport { endOfDay, format, startOfDay } from 'date-fns';\n\nimport {\n    approveBooking,\n    Booking,\n    checkinBooking,\n    queryBookings,\n    rejectBooking,\n    saveBooking,\n} from '@placeos/bookings';\nimport {\n    AsyncHandler,\n    notifyError,\n    notifyInfo,\n    notifySuccess,\n    openConfirmModal,\n} from '@placeos/common';\nimport { Desk, OrganisationService } from '@placeos/organisation';\n\nimport { generateQRCode } from 'libs/common/src/lib/qr-code';\n\nexport interface DeskFilters {\n    date?: number;\n    zones?: string[];\n    show_map?: boolean;\n    search?: string;\n}\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class DesksStateService extends AsyncHandler {\n    private _filters = new BehaviorSubject<DeskFilters>({});\n    private _new_desks = new BehaviorSubject<Desk[]>([]);\n    private _desk_bookings: Booking[] = [];\n    private _desks: Desk[] = [];\n    private _loading = new BehaviorSubject<boolean>(false);\n\n    public readonly new_desks = this._new_desks.asObservable();\n\n    public get new_desk_count() {\n        return this._new_desks.getValue()?.length || 0;\n    }\n\n    public readonly loading = this._loading.asObservable();\n\n    public readonly filters = this._filters.asObservable();\n\n    public readonly desks: Observable<Desk[]> = this._filters.pipe(\n        debounceTime(500),\n        switchMap((filters) => {\n            const zones = filters.zones || [];\n            return !zones.includes('All')\n                ? showMetadata(zones[0], 'desks').pipe(map((m) => m.details))\n                : listChildMetadata(this._org.building?.id, {\n                      name: 'desks',\n                  }).pipe(\n                      map((m) =>\n                          m\n                              .map((i) => i.metadata.desks.details)\n                              .reduce((c: any[], i: any[]) => [...c, ...i], [])\n                      )\n                  );\n        }),\n        catchError((_) => []),\n        map((list) => {\n            if (!(list instanceof Array)) list = [];\n            list.sort((a, b) => a.name.localeCompare(b.name));\n            this._desks = list.map(\n                (i) =>\n                    new Desk({\n                        ...i,\n                        qr_code: '',\n                    })\n            );\n            return this._desks;\n        }),\n        shareReplay(1)\n    );\n    public readonly bookings = this._filters.pipe(\n        debounceTime(500),\n        switchMap((filters) => {\n            this._loading.next(true);\n            const date = filters.date ? new Date(filters.date) : new Date();\n            let zones = (filters.zones || []).filter(\n                (z: any) => z !== -1 && z !== '-1' && z !== 'All'\n            );\n            if (!zones?.length) {\n                zones = this._org\n                    .levelsForBuilding(this._org.building)\n                    .map((i) => i.id);\n            }\n            return queryBookings({\n                period_start: Math.floor(startOfDay(date).valueOf() / 1000),\n                period_end: Math.floor(endOfDay(date).valueOf() / 1000),\n                type: 'desk',\n                zones: (zones || []).join(','),\n                include_checked_out: true,\n            });\n        }),\n        map((list) => {\n            list.sort((a, b) => a.date - b.date);\n            this._desk_bookings = list.map(\n                (_) =>\n                    new Booking({\n                        ..._,\n                        extension_data: {\n                            ..._.extension_data,\n                            checkin_qr_code: generateQRCode(\n                                `/workplace/#/book/code?asset_id=${encodeURIComponent(\n                                    _.asset_id\n                                )}`\n                            ),\n                        },\n                    })\n            );\n            this._loading.next(false);\n            return list;\n        }),\n        shareReplay(1)\n    );\n\n    constructor(private _org: OrganisationService, private _dialog: MatDialog) {\n        super();\n    }\n\n    public setFilters(filters: DeskFilters) {\n        if (filters.zones?.includes('All')) {\n            filters.zones = [\n                'All',\n                ...this._org\n                    .levelsForBuilding(this._org.building)\n                    .map((lvl) => lvl.id),\n            ];\n        } else if (\n            filters.zones &&\n            this._filters.getValue()?.zones?.includes('All')\n        ) {\n            filters.zones = [];\n        }\n        this._filters.next({ ...this._filters.getValue(), ...filters });\n    }\n\n    public startPolling(delay: number = 30 * 1000) {\n        this.interval(\n            'poll',\n            () => this.setFilters(this._filters.getValue()),\n            delay\n        );\n    }\n\n    public stopPolling() {\n        this.clearInterval('poll');\n    }\n\n    public addDesks(list: Desk[]) {\n        this._new_desks.next(this._new_desks.getValue().concat(list));\n    }\n\n    public clearNewDesks() {\n        this._new_desks.next([]);\n    }\n\n    public async checkinDesk(desk: Booking) {\n        const success = await checkinBooking(desk.id, true)\n            .toPromise()\n            .catch((_) => 'failed');\n        success === 'failed'\n            ? notifyError('Error checking in desk booking')\n            : notifySuccess(`Checked in ${desk.user_name}.`);\n    }\n\n    public async approveDesk(desk: Booking) {\n        const success = await approveBooking(desk.id)\n            .toPromise()\n            .catch((_) => 'failed');\n        success === 'failed'\n            ? notifyError('Error approving in desk booking')\n            : notifySuccess(\n                  `Approved desk booking for ${desk.user_name} on ${format(\n                      desk.date,\n                      'MMM do'\n                  )}.`\n              );\n    }\n\n    public async rejectDesk(desk: Booking) {\n        const success = await rejectBooking(desk.id)\n            .toPromise()\n            .catch((_) => 'failed');\n        success === 'failed'\n            ? notifyError('Error rejecting in desk booking')\n            : notifySuccess(\n                  `Rejected desk booking for ${desk.user_name} on ${format(\n                      desk.date,\n                      'MMM do'\n                  )}.`\n              );\n    }\n\n    public async giveAccess(desk: Booking) {\n        const success = await saveBooking(\n            new Booking({ ...desk, access: true })\n        )\n            .toPromise()\n            .catch((_) => 'failed');\n        if (success === 'failed')\n            return notifyError('Error giving building access booking host');\n        notifySuccess(\n            `Successfully gave building access to ${desk.user_name} for desk booking.`\n        );\n        this._desk_bookings = [...this._desk_bookings, success] as any;\n    }\n\n    public async rejectAllDesks() {\n        const list = this._desk_bookings || [];\n        if (list.length <= 0)\n            return notifyInfo('No desks to reject for the selected date');\n        const resp = await openConfirmModal(\n            {\n                title: 'Cancel all desk bookings',\n                content:\n                    'Are you sure you want to cancel all bookings for the selected date?',\n                icon: {\n                    type: 'icon',\n                    class: 'material-icons',\n                    content: 'delete',\n                },\n            },\n            this._dialog\n        );\n        if (resp.reason === 'done') return;\n        resp.loading('Rejecting all desks for selected date...');\n        await Promise.all(\n            list.map((desk) => rejectBooking(desk.id).toPromise())\n        );\n        notifySuccess(\n            'Successfully rejected all desk bookings for selected date.'\n        );\n        resp.close();\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { MatDialog, MatDialogRef } from '@angular/material/dialog';\nimport {\n    currentUser,\n    DialogEvent,\n    notifyError,\n    notifySuccess,\n} from '@placeos/common';\nimport { Desk, OrganisationService } from '@placeos/organisation';\nimport { StaffUser, User } from '@placeos/users';\nimport { endOfDay, getUnixTime, startOfDay } from 'date-fns';\nimport { first, map } from 'rxjs/operators';\n\nimport { queryBookings, saveBooking } from './bookings.fn';\nimport { DeskConfirmModalComponent } from './desk-confirm-modal.component';\nimport { DeskQuestionsModalComponent } from './desk-questions-modal.component';\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class DesksService {\n    public can_set_date = true;\n    public error_on_host = true;\n\n    constructor(\n        private _org: OrganisationService,\n        private _dialog: MatDialog\n    ) {}\n\n    public async bookDesk({\n        desks,\n        host,\n        reason,\n        attendees,\n        date,\n    }: {\n        desks: Desk[];\n        host?: StaffUser;\n        attendees?: User[];\n        reason?: string;\n        date?: Date;\n    }) {\n        if (this.error_on_host && !host) {\n            return notifyError('You need to select a host to book a desk.');\n        } else {\n            host = host || currentUser();\n        }\n        reason = reason || '';\n        const level = this._org.levelWithID(\n            desks[0].zone instanceof Array ? desks[0].zone : [desks[0].zone?.id]\n        );\n        let ref: MatDialogRef<any> = this._dialog.open(\n            DeskQuestionsModalComponent\n        );\n        let success = await Promise.race([\n            ref.componentInstance.event\n                .pipe(first((_: DialogEvent) => _.reason === 'done'))\n                .toPromise(),\n            ref\n                .afterClosed()\n                .pipe(map((_) => null))\n                .toPromise(),\n        ]);\n        if (!success) return;\n        ref.close();\n        ref = this._dialog.open(DeskConfirmModalComponent, {\n            data: {\n                host,\n                desks,\n                date: date ? new Date(date) : new Date(),\n                reason,\n                level,\n                can_set_date: this.can_set_date,\n            },\n        });\n        success = await Promise.race([\n            ref.componentInstance.event\n                .pipe(first((_: DialogEvent) => _.reason === 'done'))\n                .toPromise(),\n            ref\n                .afterClosed()\n                .pipe(map((_) => null))\n                .toPromise(),\n        ]);\n        if (!success) return;\n        host = ref.componentInstance.host || host;\n        date = ref.componentInstance.date || date;\n        reason = ref.componentInstance.reason || reason;\n        if (!host) {\n            ref.close();\n            return notifyError('You need to select a host to book a desk. ');\n        }\n        ref.componentInstance.loading =\n            'Checking for existing desk bookings...';\n        const bookings = await queryBookings({\n            type: 'desk',\n            period_start: getUnixTime(startOfDay(date || new Date())),\n            period_end: getUnixTime(endOfDay(date || new Date())),\n        }).toPromise();\n        const desk_list = bookings.filter(\n            (d) => d.user_email.toLowerCase() === host.email.toLowerCase()\n        );\n        if (desk_list?.length) {\n            ref.close();\n            return notifyError(\n                'You currently already have a desk booked for the selected date.'\n            );\n        }\n        ref.componentInstance.loading = 'Booking desk...';\n        const users = [host, ...(attendees || [])];\n        await Promise.all([\n            desks.map((desk, idx) =>\n                this.makeDeskBooking(\n                    desk,\n                    host,\n                    date.valueOf() || new Date().valueOf(),\n                    reason,\n                    users[idx]\n                )\n            ),\n        ]);\n        notifySuccess('Successfully booked desk');\n        ref.close();\n        return true;\n    }\n\n    private async makeDeskBooking(\n        desk: Desk,\n        host: StaffUser,\n        date: number,\n        reason: string,\n        for_user: User = null\n    ) {\n        const location = `${desk.zone?.name}-${desk.id}`;\n        const level = this._org.levelWithID(\n            desk.zone instanceof Array ? desk.zone : [desk.zone?.id]\n        );\n        const zones = desk.zone?.id\n            ? [desk.zone?.id, level?.parent_id]\n            : [level?.parent_id];\n        const booking_data = {\n            booking_start: getUnixTime(startOfDay(date)),\n            user_id: for_user?.id || host.id,\n            user_name: for_user?.name || host.name,\n            user_email: for_user?.email || host.email,\n            booking_end: Math.floor(endOfDay(date).valueOf() / 1000),\n            asset_id: desk.id,\n            asset_name: desk.name,\n            title: reason,\n            description: location,\n            zones,\n            booking_type: 'desk',\n            extension_data: {\n                map_id: desk?.map_id || desk?.id,\n                groups: desk.groups,\n                for_user: for_user?.email,\n            },\n        };\n        return saveBooking(booking_data as any).toPromise();\n    }\n}\n"],"x_google_ignoreList":[]}