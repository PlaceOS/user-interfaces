{"version":3,"sources":["./apps/concierge/src/app/desks/desks-state.service.ts"],"names":["DesksStateService","_org","_dialog","super","_filters","_desk_bookings","_desks","_loading","loading","this","asObservable","filters","desks","pipe","zones","includes","building","id","name","m","map","i","metadata","details","reduce","c","_","list","Array","sort","a","b","localeCompare","qr_code","encodeURIComponent","bookings","next","date","Date","filter","z","length","levelsForBuilding","period_start","Math","floor","valueOf","period_end","type","join","extension_data","checkin_qr_code","asset_id","lvl","getValue","console","warn","delay","interval","setFilters","clearInterval","desk","toPromise","catch","user_name","success","access","ref","open","data","title","content","icon","class","Promise","resolve","reject","componentInstance","event","reason","subscribe","all","close","afterClosed","then"],"mappings":"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","file":"common.js","sourcesContent":["import { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport {\n    catchError,\n    debounceTime,\n    first,\n    map,\n    shareReplay,\n    switchMap,\n} from 'rxjs/operators';\nimport { endOfDay, format, startOfDay } from 'date-fns';\n\nimport {\n    approveBooking,\n    Booking,\n    checkinBooking,\n    queryBookings,\n    rejectBooking,\n    saveBooking,\n} from '@placeos/bookings';\nimport {\n    BaseClass,\n    notifyError,\n    notifyInfo,\n    notifySuccess,\n} from '@placeos/common';\nimport { listChildMetadata, showMetadata } from '@placeos/ts-client';\nimport { Desk, OrganisationService } from '@placeos/organisation';\nimport { MatDialog } from '@angular/material/dialog';\nimport { ConfirmModalComponent } from '@placeos/components';\n\nimport { generateQRCode } from 'libs/common/src/lib/qr-code';\n\nexport interface DeskFilters {\n    date?: number;\n    zones?: string[];\n    show_map?: boolean;\n    search?: string;\n}\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class DesksStateService extends BaseClass {\n    private _filters = new BehaviorSubject<DeskFilters>({});\n    private _desk_bookings: Booking[] = [];\n    private _desks: Desk[] = [];\n    private _loading = new BehaviorSubject<boolean>(false);\n\n    public readonly loading = this._loading.asObservable();\n\n    public readonly filters = this._filters.asObservable();\n\n    public readonly desks: Observable<Desk[]> = this._filters.pipe(\n        debounceTime(500),\n        switchMap((filters) => {\n            const zones = filters.zones || [];\n            return !zones.includes('All')\n                ? showMetadata(zones[0], 'desks').pipe(map((m) => m.details))\n                : listChildMetadata(this._org.building?.id, {\n                      name: 'desks',\n                  }).pipe(\n                      map((m) =>\n                          m\n                              .map((i) => i.metadata.desks.details)\n                              .reduce((c: any[], i: any[]) => [...c, ...i], [])\n                      )\n                  );\n        }),\n        catchError((_) => []),\n        map((list) => {\n            if (!(list instanceof Array)) list = [];\n            list.sort((a, b) => a.name.localeCompare(b.name));\n            this._desks = list.map(\n                (i) =>\n                    new Desk({\n                        ...i,\n                        qr_code: generateQRCode(\n                            `/workplace/#/book/code?checkin=${encodeURIComponent(\n                                i.id\n                            )}`\n                        ),\n                    })\n            );\n            return this._desks;\n        }),\n        shareReplay()\n    );\n\n    public readonly bookings = this._filters.pipe(\n        debounceTime(500),\n        switchMap((filters) => {\n            this._loading.next(true);\n            const date = filters.date ? new Date(filters.date) : new Date();\n            let zones = (filters.zones || []).filter(\n                (z: any) => z !== -1 && z !== '-1' && z !== 'All'\n            );\n            if (!zones?.length) {\n                zones = this._org\n                    .levelsForBuilding(this._org.building)\n                    .map((i) => i.id);\n            }\n            return queryBookings({\n                period_start: Math.floor(startOfDay(date).valueOf() / 1000),\n                period_end: Math.floor(endOfDay(date).valueOf() / 1000),\n                type: 'desk',\n                zones: (zones || []).join(','),\n            });\n        }),\n        map((list) => {\n            list.sort((a, b) => a.date - b.date);\n            this._desk_bookings = list.map(\n                (_) =>\n                    new Booking({\n                        ..._,\n                        extension_data: {\n                            ..._.extension_data,\n                            checkin_qr_code: generateQRCode(\n                                `/workplace/#/book/code?checkin=${encodeURIComponent(\n                                    _.asset_id\n                                )}`\n                            ),\n                        },\n                    })\n            );\n            this._loading.next(false);\n            return list;\n        }),\n        shareReplay()\n    );\n\n    constructor(private _org: OrganisationService, private _dialog: MatDialog) {\n        super();\n    }\n\n    public setFilters(filters: DeskFilters) {\n        if (filters.zones?.includes('All')) {\n            filters.zones = [\n                'All',\n                ...this._org\n                    .levelsForBuilding(this._org.building)\n                    .map((lvl) => lvl.id),\n            ];\n        } else if (\n            filters.zones &&\n            this._filters.getValue()?.zones?.includes('All')\n        ) {\n            filters.zones = [];\n        }\n        console.warn('Filters:', filters);\n        this._filters.next({ ...this._filters.getValue(), ...filters });\n    }\n\n    public startPolling(delay: number = 30 * 1000) {\n        this.interval(\n            'poll',\n            () => this.setFilters(this._filters.getValue()),\n            delay\n        );\n    }\n\n    public stopPolling() {\n        this.clearInterval('poll');\n    }\n\n    public async checkinDesk(desk: Booking) {\n        const success = await checkinBooking(desk.id, true)\n            .toPromise()\n            .catch((_) => 'failed');\n        success === 'failed'\n            ? notifyError('Error checking in desk booking')\n            : notifySuccess(`Checked in ${desk.user_name}.`);\n    }\n\n    public async approveDesk(desk: Booking) {\n        const success = await approveBooking(desk.id)\n            .toPromise()\n            .catch((_) => 'failed');\n        success === 'failed'\n            ? notifyError('Error approving in desk booking')\n            : notifySuccess(\n                  `Approved desk booking for ${desk.user_name} on ${format(\n                      desk.date,\n                      'MMM Do'\n                  )}.`\n              );\n    }\n\n    public async rejectDesk(desk: Booking) {\n        const success = await rejectBooking(desk.id)\n            .toPromise()\n            .catch((_) => 'failed');\n        success === 'failed'\n            ? notifyError('Error rejecting in desk booking')\n            : notifySuccess(\n                  `Rejected desk booking for ${desk.user_name} on ${format(\n                      desk.date,\n                      'MMM Do'\n                  )}.`\n              );\n    }\n\n    public async giveAccess(desk: Booking) {\n        const success = await saveBooking(\n            new Booking({ ...desk, access: true })\n        )\n            .toPromise()\n            .catch((_) => 'failed');\n        if (success === 'failed')\n            return notifyError('Error giving building access booking host');\n        notifySuccess(\n            `Successfully gave building access to ${desk.user_name} for desk booking.`\n        );\n        this._desk_bookings = [...this._desk_bookings, success] as any;\n    }\n\n    public async rejectAllDesks() {\n        const list = this._desk_bookings || [];\n        if (list.length > 0) {\n            const ref = this._dialog.open(ConfirmModalComponent, {\n                data: {\n                    title: 'Cancel all desk bookings',\n                    content:\n                        'Are you sure you want to cancel all bookings for the selected date?',\n                    icon: {\n                        type: 'icon',\n                        class: 'material-icons',\n                        content: 'delete',\n                    },\n                },\n            });\n            return new Promise((resolve, reject) => {\n                let success = false;\n                ref.componentInstance.event\n                    .pipe(first((_) => _.reason === 'done'))\n                    .subscribe(async () => {\n                        ref.componentInstance.loading =\n                            'Rejecting all desks for selected date...';\n                        success = true;\n                        await Promise.all(\n                            list.map((desk) =>\n                                rejectBooking(desk.id).toPromise()\n                            )\n                        );\n                        resolve('');\n                        notifySuccess(\n                            'Successfull rejected all desk bookings for selected date.'\n                        );\n                        ref.close();\n                    });\n                ref.afterClosed()\n                    .toPromise()\n                    .then(() => {\n                        if (!success) reject();\n                    });\n            });\n        } else {\n            notifyInfo('No desks to reject for the selected date');\n        }\n    }\n}\n"],"sourceRoot":"webpack:///"}