{"version":3,"sources":["./libs/events/src/lib/validators.ts","./libs/events/src/lib/utilities.ts","./node_modules/date-fns/esm/setMinutes/index.js","./libs/events/src/lib/events.fn.ts"],"names":["endInFuture","control","parent","get","isAfter","Date","value","duration","generateEventForm","event","form","id","host","organiser","creator","calendar","attendees","resources","title","body","private","date","all_day","recurring","recurrence","recurring_master_id","master","attachments","catering","extension_data","visitor_type","ext","location","needs_space","needs_parking","system","valueChanges","subscribe","o","controls","setValue","email","l","length","disable","state","add","dirtyDate","dirtyMinutes","requiredArgs","arguments","toDate","minutes","toInteger","setMinutes","setHours","days","EVENTS_ENDPOINT","showEvent","q","query","encodeURIComponent","pipe","item","saveEvent","data","method","toJSON","updateEvent","createEvent","checkinEventGuest","guest_id"],"mappings":"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","file":"common.js","sourcesContent":["import { AbstractControl } from '@angular/forms';\nimport { addMinutes, isAfter, isBefore } from 'date-fns';\n\nexport const endInFuture = (control: AbstractControl) => {\n    if (\n        control.parent?.get('date') &&\n        isAfter(\n            new Date(),\n            addMinutes(control.parent.get('date').value, control.value)\n        )\n    ) {\n        return { duration: true };\n    }\n    return null;\n};\n\n/** Check that date in unix ms is in the future */\nexport function isFuture(\n    control: AbstractControl\n): { [key: string]: boolean } | null {\n    return control.value && isBefore(control.value, new Date())\n        ? { is_future: true }\n        : null;\n}\n","import { FormGroup, FormControl, Validators } from '@angular/forms';\nimport {\n    add,\n    formatDuration,\n    differenceInMinutes,\n    getTime,\n    isSameDay,\n    format,\n    startOfMinute,\n    setHours,\n    setMinutes,\n    addMinutes,\n} from 'date-fns';\nimport { timePeriodsIntersect, unique } from '@placeos/common';\n\nimport { CalendarEvent } from './event.class';\nimport { endInFuture } from './validators';\nimport { getNextFreeTimeSlot } from './helpers';\n\nlet BOOKING_DATE = add(setMinutes(setHours(new Date(), 6), 0), { days: -1 });\n\nexport function generateEventForm(event: CalendarEvent): FormGroup {\n    const form = new FormGroup({\n        id: new FormControl(event.id),\n        host: new FormControl(event.host || '', [Validators.required]),\n        organiser: new FormControl(event.organiser || {}, [\n            Validators.required,\n        ]),\n        creator: new FormControl(event.creator, [Validators.required]),\n        calendar: new FormControl(event.calendar),\n        attendees: new FormControl(event.attendees || []),\n        resources: new FormControl(event.resources || []),\n        title: new FormControl(event.title, [Validators.required]),\n        body: new FormControl(event.body),\n        private: new FormControl(event.private),\n        date: new FormControl(event.date, [Validators.required]),\n        duration: new FormControl(event.duration, [endInFuture]),\n        all_day: new FormControl(event.all_day),\n        recurring: new FormControl(event.recurring),\n        recurrence: new FormControl(event.recurrence),\n        recurring_master_id: new FormControl(event.recurring_master_id),\n        master: new FormControl(event.master),\n        attachments: new FormControl(event.attachments),\n        catering: new FormControl(event.extension_data.catering || []),\n        // has_catering: new FormControl(event.has_catering || false),\n        visitor_type: new FormControl(event.ext('visitor_type')),\n        location: new FormControl(event.location),\n        needs_space: new FormControl(true),\n        needs_parking: new FormControl(event.ext('needs_parking') || false),\n        system: new FormControl(event.system),\n    });\n    form.get('organiser').valueChanges.subscribe((o) =>\n        form.controls.host.setValue(o?.email)\n    );\n    form.get('resources').valueChanges.subscribe((l) =>\n        form.controls.system.setValue(l.length ? l[0] : null)\n    );\n    if (event.id) {\n        form.get('host').disable();\n        form.get('organiser').disable();\n    }\n    if (event.state === 'started') form.get('date').disable();\n    return form;\n}\n\n/**\n * Set the initial time used for generating mock bookings\n * @param time New initial time as ms from UTC epoch\n */\nexport function setMockBookingStartDatetime(time: number) {\n    BOOKING_DATE = startOfMinute(new Date(time));\n}\n\n/**\n * Get current status within bookings\n * @param bookings List of bookings\n * @param host Host of the new event\n * @param date Datetime of the new event\n */\nexport function statusFromBookings(\n    bookings: CalendarEvent[],\n    bookable: boolean,\n    requestable: boolean,\n    date: number = getTime(new Date())\n) {\n    const now = new Date(date);\n    const next_free_slot = getNextFreeTimeSlot(bookings, date, 5);\n    const start = new Date(next_free_slot.start);\n    const end = new Date(next_free_slot.end);\n    const currently_free = timePeriodsIntersect(\n        date,\n        date,\n        next_free_slot.start,\n        next_free_slot.end\n    );\n    const time_until_next_block = formatDuration({\n        minutes: currently_free\n            ? differenceInMinutes(end, now)\n            : differenceInMinutes(start, now),\n    });\n    const free_tomorrow = !currently_free && !isSameDay(start, now);\n    const free_today = currently_free && !isSameDay(end, now);\n    return {\n        status: !bookable\n            ? 'Not Bookable'\n            : currently_free\n            ? requestable\n                ? 'Available by Request'\n                : 'Available'\n            : 'Meeting in Progress',\n        available_until: free_today\n            ? 'No meetings today'\n            : currently_free\n            ? `Free until ${format(end, 'h:mm B')}(${time_until_next_block})`\n            : free_tomorrow\n            ? 'Unavailable today'\n            : `Free at ${format(start, 'h:mm B')}(${time_until_next_block})`,\n    };\n}\n\nexport function replaceBookings(\n    list: CalendarEvent[],\n    new_bookings: CalendarEvent[],\n    filter_options: { space: string; from: number; to: number }\n) {\n    const from = filter_options.from;\n    const to = filter_options.to;\n    const filtered_list = list.filter((booking) => {\n        const start = new Date(booking.date);\n        const end = addMinutes(start, booking.duration);\n        return (\n            !booking.resources.find(\n                (space) => space.email === filter_options.space\n            ) || !timePeriodsIntersect(from, to, start.valueOf(), end.valueOf())\n        );\n    });\n    const updated_list = filtered_list.concat(new_bookings);\n    updated_list.sort((a, b) => a.date - b.date);\n    return unique(updated_list, 'id');\n}\n","import toInteger from \"../_lib/toInteger/index.js\";\nimport toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name setMinutes\n * @category Minute Helpers\n * @summary Set the minutes to the given date.\n *\n * @description\n * Set the minutes to the given date.\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} minutes - the minutes of the new date\n * @returns {Date} the new date with the minutes set\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Set 45 minutes to 1 September 2014 11:30:40:\n * var result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)\n * //=> Mon Sep 01 2014 11:45:40\n */\n\nexport default function setMinutes(dirtyDate, dirtyMinutes) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var minutes = toInteger(dirtyMinutes);\n  date.setMinutes(minutes);\n  return date;\n}","import { del, get, patch, post, put } from '@placeos/ts-client';\nimport { toQueryString } from 'libs/common/src/lib/api';\nimport { GuestUser } from 'libs/users/src/lib/user.class';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { CalendarEvent } from './event.class';\n\n\n\nexport interface CalendarEventQueryParams {\n    /** Comma seperated list of zone ids to check availability */\n    zone_ids?: string;\n    /** Comma seperated list of system(space) ids to check availability */\n    system_ids?: string;\n    /** Comma seperated list of calendar ids to check availability */\n    calendars?: string;\n    /** Epoch in seconds for the start of the availability period */\n    period_start: number;\n    /** Epoch in seconds for the end of the availability period */\n    period_end: number;\n    /** Whether to include cancelled events in the returned list */\n    include_cancelled?: boolean;\n}\n\nexport interface CalendarEventShowParams {\n    /** ID of the personal calendar to grab the events details from */\n    calendar?: string;\n    /** ID of the system/space to get the associated calendar ID */\n    system_id?: string;\n}\n\nconst EVENTS_ENDPOINT = `/api/staff/v1/events`;\n\n/**\n * List events\n * @param q Parameters to pass to the API request\n */\nexport function queryEvents(\n    q: CalendarEventQueryParams\n): Observable<CalendarEvent[]> {\n    const query = toQueryString(q);\n    return get(`${EVENTS_ENDPOINT}${query ? '?' + query : ''}`).pipe(\n        map((list) => list.map((e) => new CalendarEvent(e)))\n    );\n}\n\n/**\n * Get event details\n * @param id ID of the event to grab\n * @param q Parameters to pass to the API request\n */\nexport function showEvent(id: string, q: CalendarEventShowParams = {}) {\n    const query = toQueryString(q);\n    return get(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}${\n            query ? '?' + query : ''\n        }`\n    ).pipe(map((item) => new CalendarEvent(item)));\n}\n\n/**\n * Create new calendar event and add it to the database\n * @param data New calendar event fields\n */\nexport function createEvent(data: Partial<CalendarEvent>) {\n    return post(`${EVENTS_ENDPOINT}`, new CalendarEvent(data).toJSON()).pipe(\n        map((item) => new CalendarEvent(item))\n    );\n}\n\n/**\n * Update an existing calendar event\n * @param id ID of the event to update\n * @param data New values for event fields\n * @param q Parameters to pass to the API request\n * @param method HTTP verb to use with API request\n */\nexport function updateEvent(\n    id: string,\n    data: Partial<CalendarEvent>,\n    q: CalendarEventShowParams = {},\n    method: 'put' | 'patch' = 'patch'\n) {\n    const query = toQueryString(q);\n    return (method === 'patch' ? patch : put)(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}${\n            query ? '?' + query : ''\n        }`,\n        new CalendarEvent(data).toJSON()\n    ).pipe(map((item) => new CalendarEvent(item)));\n}\n\n/**\n * Save changes to or create a calendar event\n * @param data State of the calendar event\n * @param q Parameters to pass to the API request\n */\nexport const saveEvent = (\n    data: Partial<CalendarEvent>,\n    q?: CalendarEventShowParams\n) => (data.id ? updateEvent(data.id, data, q) : createEvent(data));\n\n/**\n * Remove calendar event from the database\n * @param id ID of the event to remove\n * @param q Parameters to pass to the API request\n */\nexport function removeEvent(id: string, q: CalendarEventShowParams = {}) {\n    const query = toQueryString(q);\n    return del(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}${\n            query ? '?' + query : ''\n        }`,\n        {\n            response_type: 'void',\n        }\n    );\n}\n\n/**\n * Set the approval state of the event to approved\n * @param id ID of the event to approve\n * @param system_id Associated system to approve\n */\nexport function approveEvent(id: string, system_id: string) {\n    return post(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(\n            id\n        )}/approve?system_id=${encodeURIComponent(system_id)}`,\n        ''\n    ).pipe(map((item) => new CalendarEvent(item)));\n}\n\n/**\n * Set the approval state of the event to rejected\n * @param id ID of the event to reject\n * @param system_id Associated system to reject\n */\nexport function rejectEvent(id: string, system_id: string) {\n    return post(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(\n            id\n        )}/reject?system_id=${encodeURIComponent(system_id)}`,\n        ''\n    ).pipe(map((item) => new CalendarEvent(item)));\n}\n\n/**\n * List guests for event\n * @param id ID of the event to grab\n * @param q Parameters to pass to the API request\n */\nexport function queryEventGuests(\n    id: string,\n    q: CalendarEventShowParams = {}\n): Observable<GuestUser[]> {\n    const query = toQueryString(q);\n    return get(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}/guests${\n            query ? '?' + query : ''\n        }`\n    ).pipe(map((list) => list.map((item) => new GuestUser(item))));\n}\n\n/**\n * Set the checkin state of an event guest\n * @param id ID of the event to grab\n * @param guest_id ID of the guest to update\n * @param state New checkin state of the guest\n * @param q Parameters to pass to the API request\n */\nexport function checkinEventGuest(\n    id: string,\n    guest_id: string,\n    state: boolean,\n    q: CalendarEventShowParams = {}\n) {\n    const query = toQueryString({ ...q, state });\n    return post(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}/guests/${guest_id}${\n            query ? '?' + query : ''\n        }`,\n        ''\n    ).pipe(map((item) => new GuestUser(item)));\n}\n"],"sourceRoot":"webpack:///"}