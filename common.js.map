{"version":3,"file":"common.js","mappings":"oUA2BO,IAAMA,EAAb,MAAM,MAAOA,UAA6BC,KAH1CC,kCAIYC,WAAQ,IAAIC,IAAgB,GAC5BD,cAAW,IAAIC,IAAiC,CACpDC,MAAOC,KAAKC,QAERJ,cAAW,IAAIC,IAAwB,IACvCD,eAAY,IAAIC,IAA+B,IAEvCD,aAAUA,KAAKK,SAASC,eACxBN,aAAUA,KAAKO,SAASD,eACxBN,cAAWA,KAAKO,SAASD,eAEzBN,gBAAYQ,OAAM,KAAMC,MAAKC,OAAUC,IAAKC,YAAmBC,OAAIF,GAAKG,QAAQC,IAAI,aAAcJ,KAAKK,OAAY,IAEnHhB,aAAoCiB,QAAc,CAC9DjB,KAAKK,SACLL,KAAKkB,QACNT,MACCU,OAAa,MACbC,QAAS,EAAEC,MACPrB,KAAKO,SAASe,KAAK,uBACnB,MAAMC,EAAa,CACfC,cAAcC,QAAYC,OAAWL,EAAQnB,QAC7CyB,YAAYF,QAAYG,QAAQC,OAASR,EAAQnB,OAAQ,KAE7D,OAAImB,EAAQS,WACRP,EAAMO,SAAWT,EAAQS,UAE7B9B,KAAK+B,UAAUT,KACXtB,KAAK+B,UACAC,WACAC,OACItB,KACIuB,QACwB,IAArBX,EAAMC,aACa,IAAnBD,EAAMI,WACNhB,EAAEwB,KACFxB,EAAEwB,KAAoB,GAAbxB,EAAEyB,SAAgB,QAIxCC,OAAS,EACZC,QAAY,IAAKf,IAASd,MAAK8B,OAAY5B,GAAM,MACjD6B,QAAc,IAAKjB,EAAOkB,KAAM,SAAUhC,MAAK8B,OAAY5B,GAAM,UAGzE+B,OAAI,EAAEC,EAAQC,MACV,MAAMC,EAAO,IACN7C,KAAK+B,UAAUC,cACfW,KACAC,EAASX,OAAOtB,GAAkB,aAAbA,EAAEmC,SAC5BC,KAAK,CAACC,EAAGC,IAAMD,EAAEb,KAAOc,EAAEd,MAC5B,YAAKJ,UAAUT,MAAK4B,QAAOL,EAAM,OAC1BA,KAEXN,OAAY5B,GAAM,KAClBE,OAAKF,GAAMX,KAAKO,SAASe,KAAK,MAC9BN,OAAY,IAGTmC,aAAaC,EAAgB,MAChCpD,KAAKqD,SAAS,OAAQ,IAAMrD,KAAKkB,MAAMI,KAAKnB,KAAKC,OAAQgD,GAGtDE,cACHtD,KAAKuD,cAAc,QAGhBC,WAAWnC,GACdrB,KAAKK,SAASiB,KAAK,IAAKtB,KAAKK,SAAS2B,cAAeX,+EArEhDxB,KAAoB4D,GAApB5D,mCAAoB6D,QAApB7D,EAAoB,qBAFjB,SAEHA,GAAb","names":["ScheduleStateService","BaseClass","constructor","this","BehaviorSubject","start","Date","now","_options","asObservable","_loading","timer","pipe","switchMap","_","queryCalendars","tap","console","log","shareReplay","combineLatest","_poll","debounceTime","mergeMap","options","next","query","period_start","getUnixTime","startOfDay","period_end","addDays","endOfDay","calendar","_schedule","getValue","filter","timePeriodsIntersect","date","duration","forkJoin","queryEvents","catchError","queryBookings","type","map","events","bookings","list","status","sort","a","b","unique","startPolling","delay","interval","stopPolling","clearInterval","setOptions","t","factory"],"sourceRoot":"webpack:///","sources":["./apps/workplace/src/app/schedule/schedule-state.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Booking, queryBookings } from '@placeos/bookings';\nimport { queryCalendars } from '@placeos/calendar';\nimport { BaseClass, timePeriodsIntersect, unique } from '@placeos/common';\nimport { CalendarEvent, queryEvents } from '@placeos/events';\nimport { addDays, endOfDay, getUnixTime, startOfDay } from 'date-fns';\nimport { BehaviorSubject, combineLatest, forkJoin, Observable, timer } from 'rxjs';\nimport {\n    catchError,\n    debounceTime,\n    map,\n    mergeMap,\n    shareReplay,\n    switchMap,\n    tap,\n} from 'rxjs/operators';\n\nexport type BookingLike = CalendarEvent & Booking;\n\nexport interface ScheduleOptions {\n    calendar?: string;\n    start: number;\n}\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class ScheduleStateService extends BaseClass {\n    private _poll = new BehaviorSubject(0);\n    private _options = new BehaviorSubject<ScheduleOptions>({\n        start: Date.now(),\n    });\n    private _loading = new BehaviorSubject<string>('');\n    private _schedule = new BehaviorSubject<BookingLike[]>([]);\n\n    public readonly options = this._options.asObservable();\n    public readonly loading = this._loading.asObservable();\n    public readonly schedule = this._loading.asObservable();\n\n    public readonly calendars = timer(1000).pipe(switchMap(_ => queryCalendars()), tap(_ => console.log('Calendars:', _)), shareReplay(1));\n\n    public readonly events: Observable<BookingLike[]> = combineLatest([\n        this._options,\n        this._poll,\n    ]).pipe(\n        debounceTime(1000),\n        mergeMap(([options]) => {\n            this._loading.next('Loading schedule...');\n            const query: any = {\n                period_start: getUnixTime(startOfDay(options.start)),\n                period_end: getUnixTime(addDays(endOfDay(options.start), 6)),\n            };\n            if (options.calendar) {\n                query.calendar = options.calendar;\n            }\n            this._schedule.next(\n                this._schedule\n                    .getValue()\n                    .filter(\n                        (_) =>\n                            !timePeriodsIntersect(\n                                query.period_start * 1000,\n                                query.period_end * 1000,\n                                _.date,\n                                _.date + _.duration * 60 * 1000\n                            )\n                    )\n            );\n            return forkJoin([\n                queryEvents({ ...query }).pipe(catchError((_) => [])),\n                queryBookings({ ...query, type: 'desk' }).pipe(catchError((_) => [])),\n            ]);\n        }),\n        map(([events, bookings]) => {\n            const list = [\n                ...this._schedule.getValue(),\n                ...events,\n                ...bookings.filter(_ => _.status !== 'declined'),\n            ].sort((a, b) => a.date - b.date);\n            this._schedule.next(unique(list, 'id') as any);\n            return list;\n        }),\n        catchError((_) => []),\n        tap((_) => this._loading.next('')),\n        shareReplay(1)\n    );\n\n    public startPolling(delay: number = 15 * 1000) {\n        this.interval('poll', () => this._poll.next(Date.now()), delay);\n    }\n\n    public stopPolling() {\n        this.clearInterval('poll');\n    }\n\n    public setOptions(options: Partial<ScheduleOptions>) {\n        this._options.next({ ...this._options.getValue(), ...options });\n    }\n}\n"]}