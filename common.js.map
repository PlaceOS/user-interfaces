{"version":3,"file":"common.js","mappings":"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","names":["ScheduleStateService","BaseClass","constructor","_settings","super","this","BehaviorSubject","shown_types","Date","now","combineLatest","_date","_poll","pipe","tap","_","_loading","next","_update","switchMap","date","query","period_start","getUnixTime","startOfDay","period_end","endOfDay","get","queryBookings","type","map","i","newCalendarEventFromBooking","catchError","queryEvents","timeout","shareReplay","console","error","events","desks","parking","e","d","p","sort","a","b","bookings","_filters","bkns","filters","filter","CalendarEvent","includes","booking_type","asObservable","startPolling","delay","interval","stopPolling","clearInterval","setDate","toggleType","name","clear","getValue","i0","factory","start","_options","timer","queryCalendars","debounceTime","mergeMap","options","addDays","calendar","_schedule","timePeriodsIntersect","duration","forkJoin","list","status","unique","setOptions","CalendarService","_org","_calendars","q","querySpaceFreeBusy","queryCalendarAvailability","initialised","first","subscribe","init","n","load","catch","err","notifyError","_initialised","calendars","getFreeBusyDate","checkSpacesAvailability","system_ids","old_booking","result","join","toPromise","valueOf","end","addMinutes","every","availability","id","system","email","index","findIndex","block","splice","length"],"sourceRoot":"webpack:///","sources":["./apps/workplace/src/app/new-schedule/schedule-state.service.ts","./apps/workplace/src/app/schedule/schedule-state.service.ts","./libs/calendar/src/lib/calendar.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Booking, queryBookings } from '@placeos/bookings';\nimport { BaseClass, SettingsService } from '@placeos/common';\nimport {\n    CalendarEvent,\n    newCalendarEventFromBooking,\n    queryEvents,\n} from '@placeos/events';\nimport { endOfDay, getUnixTime, startOfDay } from 'date-fns';\nimport { BehaviorSubject, combineLatest, Observable } from 'rxjs';\nimport { catchError, map, shareReplay, switchMap, tap } from 'rxjs/operators';\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class ScheduleStateService extends BaseClass {\n    private _poll = new BehaviorSubject(0);\n    private _loading = new BehaviorSubject(false);\n    private _filters = new BehaviorSubject({\n        shown_types: ['event', 'desk', 'parking'],\n    });\n    private _date = new BehaviorSubject(Date.now());\n    private _update = combineLatest([this._date, this._poll]).pipe(\n        tap((_) => this._loading.next(true))\n    );\n    /** List of calendar events for the selected date */\n    public readonly events: Observable<CalendarEvent[]> = this._update.pipe(\n        switchMap(([date]) => {\n            const query = {\n                period_start: getUnixTime(startOfDay(date)),\n                period_end: getUnixTime(endOfDay(date)),\n            };\n            return this._settings.get('app.no_user_calendar')\n                ? queryBookings({ ...query, type: 'room' }).pipe(\n                      map((_) => _.map((i) => newCalendarEventFromBooking(i))),\n                      catchError((_) => [])\n                  )\n                : queryEvents({ ...query }).pipe(catchError((_) => []));\n        }),\n        tap(() => this.timeout('end_loading', () => this._loading.next(false))),\n        shareReplay(1)\n    );\n    /** List of desk bookings for the selected date */\n    public readonly desks: Observable<Booking[]> = this._update.pipe(\n        switchMap(([date]) =>\n            queryBookings({\n                period_start: getUnixTime(startOfDay(date)),\n                period_end: getUnixTime(endOfDay(date)),\n                type: 'desk',\n            }).pipe(catchError((_) => {\n                console.error(_);\n                return [];\n            }))\n        ),\n        tap(() => this.timeout('end_loading', () => this._loading.next(false))),\n        shareReplay(1)\n    );\n    /** List of parking bookings for the selected date */\n    public readonly parking: Observable<Booking[]> = this._update.pipe(\n        switchMap(([date]) =>\n            queryBookings({\n                period_start: getUnixTime(startOfDay(date)),\n                period_end: getUnixTime(endOfDay(date)),\n                type: 'parking',\n            }).pipe(catchError((_) => []))\n        ),\n        tap(() => this.timeout('end_loading', () => this._loading.next(false))),\n        shareReplay(1)\n    );\n\n    /** List of events and bookings for the selected date */\n    public readonly bookings = combineLatest([\n        this.events,\n        this.desks,\n        this.parking,\n    ]).pipe(\n        map(([e, d, p]) => [...e, ...d, ...p].sort((a, b) => a.date - b.date))\n    );\n    /** Filtered list of events and bookings for the selected date */\n    public readonly filtered_bookings = combineLatest([\n        this.bookings,\n        this._filters,\n    ]).pipe(\n        map(([bkns, filters]) =>\n            bkns.filter(\n                (_) =>\n                    (_ instanceof CalendarEvent &&\n                        filters?.shown_types?.includes('event')) ||\n                    filters?.shown_types?.includes((_ as any).booking_type)\n            )\n        )\n    );\n    /** Currently selected date */\n    public readonly filters = this._filters.asObservable();\n    /** Currently selected date */\n    public readonly date = this._date.asObservable();\n    /** Whether events and bookings are loading */\n    public readonly loading = this._loading.asObservable();\n\n    constructor(private _settings: SettingsService) {\n        super();\n    }\n\n    public startPolling(delay = 15 * 1000) {\n        this.interval('poll', () => this._poll.next(Date.now()), delay);\n        return () => this.stopPolling();\n    }\n\n    public stopPolling() {\n        this.clearInterval('poll');\n    }\n\n    public setDate(date: number) {\n        this._date.next(date);\n    }\n\n    public async toggleType(name: string, clear: boolean = false) {\n        const filters = this._filters.getValue() || { shown_types: [] };\n        const { shown_types } = filters;\n        if (shown_types && (shown_types.includes(name) || clear)) {\n            this._filters.next({\n                ...filters,\n                shown_types: shown_types.filter((_) => _ !== name),\n            });\n        } else {\n            this._filters.next({\n                ...filters,\n                shown_types: [...shown_types, name],\n            });\n        }\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { Booking, queryBookings } from '@placeos/bookings';\nimport { queryCalendars } from '@placeos/calendar';\nimport {\n    BaseClass,\n    SettingsService,\n    timePeriodsIntersect,\n    unique,\n} from '@placeos/common';\nimport {\n    CalendarEvent,\n    newCalendarEventFromBooking,\n    queryEvents,\n} from '@placeos/events';\nimport { addDays, endOfDay, getUnixTime, startOfDay } from 'date-fns';\nimport {\n    BehaviorSubject,\n    combineLatest,\n    forkJoin,\n    Observable,\n    timer,\n} from 'rxjs';\nimport {\n    catchError,\n    debounceTime,\n    map,\n    mergeMap,\n    shareReplay,\n    switchMap,\n    tap,\n} from 'rxjs/operators';\n\nexport type BookingLike = CalendarEvent & Booking;\n\nexport interface ScheduleOptions {\n    calendar?: string;\n    start: number;\n}\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class ScheduleStateService extends BaseClass {\n    private _poll = new BehaviorSubject(0);\n    private _options = new BehaviorSubject<ScheduleOptions>({\n        start: Date.now(),\n    });\n    private _loading = new BehaviorSubject<string>('');\n    private _schedule = new BehaviorSubject<BookingLike[]>([]);\n\n    public readonly options = this._options.asObservable();\n    public readonly loading = this._loading.asObservable();\n    public readonly schedule = this._loading.asObservable();\n\n    public readonly calendars = timer(1000).pipe(\n        switchMap((_) => queryCalendars()),\n        shareReplay(1)\n    );\n\n    public readonly events: Observable<BookingLike[]> = combineLatest([\n        this._options,\n        this._poll,\n    ]).pipe(\n        debounceTime(1000),\n        mergeMap(([options]) => {\n            this._loading.next('Loading schedule...');\n            const query: any = {\n                period_start: getUnixTime(startOfDay(options.start)),\n                period_end: getUnixTime(addDays(endOfDay(options.start), 6)),\n            };\n            if (options.calendar) {\n                query.calendar = options.calendar;\n            }\n            this._schedule.next(\n                this._schedule\n                    .getValue()\n                    .filter(\n                        (_) =>\n                            !timePeriodsIntersect(\n                                query.period_start * 1000,\n                                query.period_end * 1000,\n                                _.date,\n                                _.date + _.duration * 60 * 1000\n                            )\n                    )\n            );\n            return forkJoin([\n                this._settings.get('app.no_user_calendar') === true\n                    ? queryBookings({ ...query, type: 'room' }).pipe(\n                          map((_) =>\n                              _.map((i) => newCalendarEventFromBooking(i))\n                          )\n                      )\n                    : queryEvents({ ...query }),\n                queryBookings({ ...query, type: 'desk' }),\n                queryBookings({ ...query, type: 'parking' }),\n            ]).pipe(catchError((_) => []));\n        }),\n        map(([events, bookings]) => {\n            const list = [\n                ...this._schedule.getValue(),\n                ...events,\n                ...bookings.filter((_) => _.status !== 'declined'),\n            ].sort((a, b) => a.date - b.date);\n            this._schedule.next(unique(list, 'id') as any);\n            return list;\n        }),\n        catchError((_) => []),\n        tap((_) => this._loading.next('')),\n        shareReplay(1)\n    );\n\n    constructor(private _settings: SettingsService) {\n        super();\n    }\n\n    public startPolling(delay: number = 15 * 1000) {\n        this.interval('poll', () => this._poll.next(Date.now()), delay);\n    }\n\n    public stopPolling() {\n        this.clearInterval('poll');\n    }\n\n    public setOptions(options: Partial<ScheduleOptions>) {\n        this._options.next({ ...this._options.getValue(), ...options });\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { first } from 'rxjs/operators';\nimport { addMinutes, endOfDay, getUnixTime, startOfDay } from 'date-fns';\n\nimport { Calendar } from './calendar.class';\n\nimport { BaseClass, notifyError, SettingsService } from '@placeos/common';\nimport { OrganisationService } from '@placeos/organisation';\nimport { CalendarEvent } from '../../../events/src/lib/event.class';\nimport { CalendarAvailabilityQueryParams } from './calendar.interfaces';\nimport {\n    queryCalendarAvailability,\n    queryCalendars,\n    querySpaceFreeBusy,\n} from './calendar.fn';\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class CalendarService extends BaseClass {\n    private readonly _calendars = new BehaviorSubject<Calendar[]>([]);\n\n    /** Observable for the list of calendars */\n    public readonly calendar_list = this._calendars.asObservable();\n\n    /* istanbul ignore next */\n    public readonly query = () => queryCalendars();\n    /* istanbul ignore next */\n    public readonly freeBusy = (q: CalendarAvailabilityQueryParams) =>\n        querySpaceFreeBusy(q, this._org);\n    /* istanbul ignore next */\n    public readonly availability = (q: CalendarAvailabilityQueryParams) =>\n        queryCalendarAvailability(q);\n\n    constructor(\n        private _org: OrganisationService,\n        private _settings: SettingsService\n    ) {\n        super();\n        this._org.initialised\n            .pipe(first((_) => _))\n            .subscribe(() => this.init());\n    }\n\n    public async init() {\n        if (this._settings.get('app.no_user_calendar')) return;\n        await this.load().catch((err) =>\n            notifyError('Error loading calendars data')\n        );\n        this._initialised.next(true);\n    }\n\n    public get calendars(): Calendar[] {\n        return this._calendars.getValue();\n    }\n\n    /** Get Free busy for the selected day\n     * @param calendars User calendar\n     * @param date Selected day\n     */\n    public getFreeBusyDate(date: number, calendars: string) {\n        return querySpaceFreeBusy(\n            {\n                period_start: getUnixTime(startOfDay(date)),\n                period_end: getUnixTime(endOfDay(date)),\n                calendars,\n            },\n            this._org\n        );\n    }\n\n    /** Check rooms availability */\n    public async checkSpacesAvailability(\n        system_ids: string[],\n        period_start: number,\n        period_end: number,\n        old_booking?: CalendarEvent\n    ) {\n        const result = await queryCalendarAvailability({\n            period_start,\n            period_end,\n            system_ids: system_ids.join(','),\n        }).toPromise();\n        const start = new Date(old_booking?.date).valueOf();\n        const end = addMinutes(start, old_booking?.duration).valueOf();\n        const available = result.every((i) => {\n            const availability = i.availability;\n            if (old_booking && i.id === old_booking.system?.email) {\n                const index = availability.findIndex((block) => {\n                    return (\n                        block.date >= start &&\n                        addMinutes(block.date, block.duration).valueOf() <= end\n                    );\n                });\n                if (index !== -1) {\n                    availability.splice(index, 1);\n                }\n            }\n            return !availability.length;\n        });\n        return !!available;\n    }\n\n    public async load(): Promise<void> {\n        this._calendars.next(await queryCalendars().toPromise());\n    }\n}\n"],"x_google_ignoreList":[]}