{"version":3,"sources":["/home/runner/work/user-interfaces/user-interfaces/libs/events/src/lib/event.utilities.ts","/home/runner/work/user-interfaces/user-interfaces/node_modules/date-fns/esm/setMinutes/index.js","/home/runner/work/user-interfaces/user-interfaces/node_modules/date-fns/esm/setHours/index.js","/home/runner/work/user-interfaces/user-interfaces/node_modules/date-fns/esm/isAfter/index.js","/home/runner/work/user-interfaces/user-interfaces/libs/events/src/lib/events.fn.ts"],"names":["generateEventForm","event","form","id","host","required","organiser","creator","calendar","attendees","resources","title","body","private","date","duration","all_day","recurring","recurrence","recurring_master_id","master","attachments","catering","extension_data","visitor_type","location","needs_space","needs_parking","system","controls","setValidators","endInFuture","valueChanges","subscribe","o","setValue","email","disable","state","add","dirtyDate","dirtyMinutes","requiredArgs","arguments","toDate","minutes","toInteger","setMinutes","dirtyHours","hours","setHours","Date","days","control","dirtyDateToCompare","dateToCompare","getTime","isAfter","value","EVENTS_ENDPOINT","showEvent","q","query","encodeURIComponent","pipe","map","item","saveEvent","data","method","updateEvent","createEvent","checkinEventGuest","guest_id"],"mappings":"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","file":"common.ea69d135fdd4040ceffe.js","sourcesContent":["import { FormGroup, FormControl, Validators, AbstractControl } from '@angular/forms';\nimport {\n    add,\n    isBefore,\n    isAfter,\n    formatDuration,\n    differenceInMinutes,\n    getTime,\n    isSameDay,\n    format,\n    startOfMinute,\n    setHours,\n    setMinutes,\n    addMinutes,\n} from 'date-fns';\nimport { timePeriodsIntersect, unique } from '@user-interfaces/common';\n\nimport { CalendarEvent } from './event.class';\nimport { SpaceRuleOptions, SpaceRules, SpaceCheckOptions } from './event.interfaces';\n\nconst MINUTE = 1;\nconst HOUR = 60;\nconst DAY = 24 * HOUR;\nconst WEEK = 7 * DAY;\nconst MONTH = 30 * DAY;\n\nconst DURATION_MAP: { [duration: string]: number } = {\n    month: MONTH,\n    months: MONTH,\n    week: WEEK,\n    weeks: WEEK,\n    day: DAY,\n    days: DAY,\n    hour: HOUR,\n    hours: HOUR,\n    minute: MINUTE,\n    minutes: MINUTE,\n};\n\nlet BOOKING_DATE = add(setMinutes(setHours(new Date(), 6), 0), { days: -1 });\n\nexport function generateEventForm(event: CalendarEvent): FormGroup {\n    const form = new FormGroup({\n        id: new FormControl(event.id),\n        host: new FormControl(event.host || '', [Validators.required]),\n        organiser: new FormControl(event.organiser || {}, [\n            Validators.required,\n        ]),\n        creator: new FormControl(event.creator, [Validators.required]),\n        calendar: new FormControl(event.calendar),\n        attendees: new FormControl(event.attendees || []),\n        resources: new FormControl(event.resources || []),\n        title: new FormControl(event.title, [Validators.required]),\n        body: new FormControl(event.body),\n        private: new FormControl(event.private),\n        date: new FormControl(event.date, [Validators.required]),\n        duration: new FormControl(event.duration),\n        all_day: new FormControl(event.all_day),\n        recurring: new FormControl(event.recurring),\n        recurrence: new FormControl(event.recurrence),\n        recurring_master_id: new FormControl(event.recurring_master_id),\n        master: new FormControl(event.master),\n        attachments: new FormControl(event.attachments),\n        catering: new FormControl(event.extension_data.catering || []),\n        // has_catering: new FormControl(event.has_catering || false),\n        visitor_type: new FormControl(event.extension_data.visitor_type),\n        location: new FormControl(event.location),\n        needs_space: new FormControl(true),\n        needs_parking: new FormControl(event.needs_parking || false),\n        system: new FormControl(event.system),\n    });\n    form.controls.duration.setValidators([endInFuture(form)]);\n    form.controls.organiser.valueChanges.subscribe((o) => {\n        form.controls.host.setValue(o?.email);\n    });\n    if (event.id) {\n        form.controls.host.disable();\n        form.controls.organiser.disable();\n    }\n    if (event.state === 'started') {\n        form.controls.date.disable();\n    }\n    return form;\n}\n\nexport const endInFuture = (form: FormGroup) => (control: AbstractControl) => {\n    if (\n        form.controls.date &&\n        isAfter(\n            new Date(),\n            new Date(form.controls.date.value + control.value * 60 * 1000)\n        )\n    ) {\n        return { duration: true };\n    }\n    return null;\n};\n\n/** Array is not empty */\nexport function isNotEmpty(control: AbstractControl): { [key: string]: boolean } | null {\n    if (Array.isArray(control.value) && !control.value.length) {\n        return { isNotEmpty: true };\n    }\n    return null;\n}\n\n/** Check that date in unix ms is in the future */\nexport function isFuture(control: AbstractControl): { [key: string]: boolean } | null {\n    if (control.value !== undefined && isBefore(new Date(control.value), new Date())) {\n        return { isFuture: true };\n    }\n    return null;\n}\n\n/**\n * Set the initial time used for generating mock bookings\n * @param time New initial time as ms from UTC epoch\n */\nexport function setMockBookingStartDatetime(time: number) {\n    BOOKING_DATE = startOfMinute(new Date(time));\n}\n\n/**\n * Get booking rules for the given user and space\n * @param user User to determine applicable rules\n * @param space Space to get rules for\n * @param time Booking start time in ms since UTC epoch\n * @param rules List of booking rules for the building\n */\nexport function rulesForSpace(options: SpaceRuleOptions): SpaceRules {\n    if (!options) {\n        throw Error('Options are needed to check for rule matches');\n    }\n    const space_rules_for_user: SpaceRules = {\n        auto_approve: true,\n        hide: true,\n    };\n    /* istanbul ignore else */\n    if (options.space) {\n        for (const type of Object.keys(options.rules)) {\n            if (\n                options.rules.hasOwnProperty(type) &&\n                options.rules[type] instanceof Array &&\n                options.space.zones.find((zone) => zone === type)\n            ) {\n                for (const rule_block of options.rules[type]) {\n                    /* istanbul ignore else */\n                    if (\n                        checkRules({\n                            user: options.user,\n                            space: options.space,\n                            time: options.time,\n                            recurr_end: options.recurr_end,\n                            duration: options.duration,\n                            rules: rule_block.conditions,\n                        })\n                    ) {\n                        const ruleset = rule_block.rules;\n                        const conditions = rule_block.conditions;\n                        space_rules_for_user.hide = false;\n                        /* istanbul ignore else */\n                        if (conditions.max_length) {\n                            space_rules_for_user.max_length = stringToMinutes(\n                                conditions.max_length as string\n                            );\n                        }\n                        /* istanbul ignore else */\n                        if (conditions.min_length) {\n                            space_rules_for_user.min_length = stringToMinutes(\n                                conditions.min_length as string\n                            );\n                        }\n                        // NOTE: use max_length in conditions instead of book_length in rules\n                        // if (ruleset.book_length) {\n                        //     space_rules_for_user.max_length = stringToMinutes(ruleset.book_length as string);\n                        // }\n                        /* istanbul ignore else */\n                        if (ruleset.auto_approve !== undefined) {\n                            space_rules_for_user.auto_approve = ruleset.auto_approve;\n                        }\n                        break;\n                    }\n                }\n            }\n            /* istanbul ignore else */\n            if (!space_rules_for_user.hide) {\n                break;\n            }\n        }\n    }\n    return space_rules_for_user;\n}\n\n/**\n * Check if user matches the given ruleset\n * @param user User to determine applicable rules\n * @param space Space to get rules for\n * @param time Booking start time in ms since UTC epoch\n * @param rules List of booking rules for the building\n */\nfunction checkRules(options: SpaceCheckOptions): boolean {\n    /* istanbul ignore else */\n    if (options.rules) {\n        const time = new Date(options.time);\n        const recurr = options.recurr_end ? new Date(options.recurr_end) : new Date();\n        const count = Object.keys(options.rules).length;\n        let matches = 0;\n        for (const key of Object.keys(options.rules)) {\n            let counter = 0;\n            const condition: string[] =\n                options.rules[key] instanceof Array\n                    ? (options.rules[key] as [])\n                    : [options.rules[key] as string];\n            switch (key) {\n                // case 'groups':\n                //     /* istanbul ignore else */\n                //     if (options.user && options.user.groups) {\n                //         counter = 0;\n                //         condition.forEach((i) =>\n                //             options.user.groups.find((j) => j === i) ? counter++ : null\n                //         );\n                //         /* istanbul ignore else */\n                //         if (counter > 0) {\n                //             matches++;\n                //         }\n                //     }\n                //     break;\n                // case 'locations':\n                //     /* istanbul ignore else */\n                //     if (options.user && options.user.location) {\n                //         counter = 0;\n                //         condition.forEach((i) =>\n                //             (options.user.last_location.name || '').indexOf(i) >= 0\n                //                 ? counter++\n                //                 : null\n                //         );\n                //         /* istanbul ignore else */\n                //         if (counter >= options.rules[key].length) {\n                //             matches++;\n                //         }\n                //     }\n                //     break;\n                case 'is_before':\n                    /* istanbul ignore else */\n                    if (options.time) {\n                        const duration = stringToMinutes(condition[0]);\n                        const check = add(new Date(), { minutes: duration });\n                        let match = isBefore(time, check);\n                        /* istanbul ignore else */\n                        if (recurr) {\n                            match = match && isBefore(recurr, check);\n                        }\n                        matches += match ? 1 : 0;\n                    }\n                    break;\n                case 'is_after':\n                    /* istanbul ignore else */\n                    if (options.time) {\n                        const duration = stringToMinutes(condition[0]);\n                        const check = add(new Date(), { minutes: duration });\n                        if (isAfter(time, check)) {\n                            matches++;\n                        }\n                    }\n                    break;\n                case 'min_length':\n                    /* istanbul ignore else */\n                    if (\n                        options.duration &&\n                        durationGreaterThanOrEqual(options.duration, condition[0])\n                    ) {\n                        matches++;\n                    }\n                    break;\n                case 'max_length':\n                    /* istanbul ignore else */\n                    if (\n                        options.duration &&\n                        durationGreaterThanOrEqual(condition[0], options.duration)\n                    ) {\n                        matches++;\n                    }\n                    break;\n            }\n        }\n        return matches >= count;\n    }\n    return false;\n}\n\n/**\n * Whether the first input is greater than the last. Converts duration strings into minutes\n * @param duration_1 First input can be a number in minutes or a duration string e.g. `1 hour`\n * @param duration_2 Second input can be a number in minutes or a duration string e.g. `30 minutes`\n */\nexport function durationGreaterThanOrEqual(\n    duration_1: string | number,\n    duration_2: string | number\n) {\n    const first: number = typeof duration_1 === 'string' ? stringToMinutes(duration_1) : duration_1;\n    const second: number =\n        typeof duration_2 === 'string' ? stringToMinutes(duration_2) : duration_2;\n    return first >= second;\n}\n\n/**\n * Conver time string into minutes\n * @param str timestring e.g. `'1 day'`, `'15 minutes'`, `'2 weeks'`\n */\nexport function stringToMinutes(str: string): number {\n    const parts = str.split(' ');\n    return +parts[0] * DURATION_MAP[parts[1]];\n}\n\n/**\n * Get current status within bookings\n * @param bookings List of bookings\n * @param host Host of the new event\n * @param date Datetime of the new event\n */\nexport function statusFromBookings(\n    bookings: CalendarEvent[],\n    bookable: boolean,\n    requestable: boolean,\n    date: number = getTime(new Date())\n) {\n    const free_slots = getFreeBookingSlots(bookings);\n    const now = new Date(date);\n    const next_free_slot = free_slots.find((slot) => {\n        const start = new Date(slot.start);\n        const end = new Date(slot.end);\n        return isAfter(start, now) || timePeriodsIntersect(date, date, slot.start, slot.end);\n    });\n    const start = new Date(next_free_slot.start);\n    const end = new Date(next_free_slot.end);\n    const currently_free = timePeriodsIntersect(\n        date,\n        date,\n        next_free_slot.start,\n        next_free_slot.end\n    );\n    const time_until_next_block = formatDuration({\n        minutes: currently_free ? differenceInMinutes(end, now) : differenceInMinutes(start, now),\n    });\n    const free_tomorrow = !currently_free && !isSameDay(start, now);\n    const free_today = currently_free && !isSameDay(end, now);\n    return {\n        status: !bookable\n            ? 'Not Bookable'\n            : currently_free\n            ? requestable\n                ? 'Available by Request'\n                : 'Available'\n            : 'Meeting in Progress',\n        available_until: free_today\n            ? 'No meetings today'\n            : currently_free\n            ? `Free until ${format(end, 'h:mm B')}(${time_until_next_block})`\n            : free_tomorrow\n            ? 'Unavailable today'\n            : `Free at ${format(start, 'h:mm B')}(${time_until_next_block})`,\n    };\n}\nexport interface IBookingSlot {\n    start: number;\n    end: number;\n}\n\n/**\n * Generate a list of free time slots between the given bookings\n * @param list List of bookings to find slots between\n * @param min_size Minimum length of a free slot in minutes\n */\nexport function getFreeBookingSlots(list: CalendarEvent[], min_size: number = 30): IBookingSlot[] {\n    /* istanbul ignore else */\n    if (!list) {\n        return [\n            {\n                start: 0,\n                end: startOfMinute(new Date()).getTime() * 10,\n            },\n        ];\n    }\n    const slots: IBookingSlot[] = [];\n    let start = new Date(0);\n    list.sort((a, b) => a.date - b.date);\n    for (const booking of list) {\n        const bkn_start = new Date(booking.date);\n        const bkn_end = add(bkn_start, { minutes: booking.duration });\n        if (isAfter(bkn_start, start)) {\n            const diff = Math.abs(differenceInMinutes(bkn_start, start));\n            /* istanbul ignore else */\n            if (diff >= min_size) {\n                slots.push({ start: start.valueOf(), end: bkn_start.valueOf() });\n            }\n            start = bkn_end;\n        } else if (startOfMinute(start).getTime() === startOfMinute(bkn_start).getTime()) {\n            start = bkn_end;\n        }\n    }\n    slots.push({\n        start: start.getTime(),\n        end: startOfMinute(new Date()).getTime() * 10,\n    });\n    return slots;\n}\n\n/**\n * Get the next free time slot from the given bookings\n * @param list List of bookings to find the next slot\n * @param date Date to find next slot after in ms since UTC epoch\n * @param min_size Minimum length of the free slot in minutes\n */\nexport function getNextFreeBookingSlot(\n    list: CalendarEvent[],\n    date: number = new Date().valueOf(),\n    min_size: number = 30\n): IBookingSlot {\n    const slots = getFreeBookingSlots(list, min_size);\n    const time = add(startOfMinute(new Date(date)), { seconds: 1 });\n    for (const block of slots) {\n        const start = startOfMinute(new Date(block.start));\n        const end = startOfMinute(new Date(block.end));\n        if (isAfter(start, time)) {\n            return block;\n        } else if (isBefore(time, end)) {\n            const duration = differenceInMinutes(end, time);\n            /* istanbul ignore else */\n            if (duration >= min_size) {\n                return block;\n            }\n        }\n    }\n    return slots[slots.length - 1];\n}\n\nexport function replaceBookings(\n    list: CalendarEvent[],\n    new_bookings: CalendarEvent[],\n    filter_options: { space: string; from: number; to: number }\n) {\n    const from = filter_options.from;\n    const to = filter_options.to;\n    const filtered_list = list.filter((booking) => {\n        const start = new Date(booking.date);\n        const end = addMinutes(start, booking.duration);\n        return (\n            !booking.resources.find((space) => space.email === filter_options.space) ||\n            !timePeriodsIntersect(from, to, start.valueOf(), end.valueOf())\n        );\n    });\n    const updated_list = filtered_list.concat(new_bookings);\n    updated_list.sort((a, b) => a.date - b.date);\n    return unique(updated_list, 'id');\n}\n","import toInteger from '../_lib/toInteger/index.js';\nimport toDate from '../toDate/index.js';\nimport requiredArgs from '../_lib/requiredArgs/index.js';\n/**\n * @name setMinutes\n * @category Minute Helpers\n * @summary Set the minutes to the given date.\n *\n * @description\n * Set the minutes to the given date.\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} minutes - the minutes of the new date\n * @returns {Date} the new date with the minutes set\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Set 45 minutes to 1 September 2014 11:30:40:\n * var result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)\n * //=> Mon Sep 01 2014 11:45:40\n */\n\nexport default function setMinutes(dirtyDate, dirtyMinutes) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var minutes = toInteger(dirtyMinutes);\n  date.setMinutes(minutes);\n  return date;\n}","import toInteger from '../_lib/toInteger/index.js';\nimport toDate from '../toDate/index.js';\nimport requiredArgs from '../_lib/requiredArgs/index.js';\n/**\n * @name setHours\n * @category Hour Helpers\n * @summary Set the hours to the given date.\n *\n * @description\n * Set the hours to the given date.\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} hours - the hours of the new date\n * @returns {Date} the new date with the hours set\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Set 4 hours to 1 September 2014 11:30:00:\n * var result = setHours(new Date(2014, 8, 1, 11, 30), 4)\n * //=> Mon Sep 01 2014 04:30:00\n */\n\nexport default function setHours(dirtyDate, dirtyHours) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var hours = toInteger(dirtyHours);\n  date.setHours(hours);\n  return date;\n}","import toDate from '../toDate/index.js';\nimport requiredArgs from '../_lib/requiredArgs/index.js';\n/**\n * @name isAfter\n * @category Common Helpers\n * @summary Is the first date after the second one?\n *\n * @description\n * Is the first date after the second one?\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * @param {Date|Number} date - the date that should be after the other one to return true\n * @param {Date|Number} dateToCompare - the date to compare with\n * @returns {Boolean} the first date is after the second date\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Is 10 July 1989 after 11 February 1987?\n * var result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))\n * //=> true\n */\n\nexport default function isAfter(dirtyDate, dirtyDateToCompare) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var dateToCompare = toDate(dirtyDateToCompare);\n  return date.getTime() > dateToCompare.getTime();\n}","import { del, get, patch, post, put } from '@placeos/ts-client';\nimport { map } from 'rxjs/operators';\nimport { toQueryString } from 'libs/common/src/lib/api';\n\nimport { CalendarEvent } from './event.class';\nimport { GuestUser } from '../../../users/src/lib/user.class';\nimport { Observable } from 'rxjs';\n\nexport interface CalendarEventQueryParams {\n    /** Comma seperated list of zone ids to check availability */\n    zone_ids?: string;\n    /** Comma seperated list of system(space) ids to check availability */\n    system_ids?: string;\n    /** Comma seperated list of calendar ids to check availability */\n    calendars?: string;\n    /** Epoch in seconds for the start of the availability period */\n    period_start: number;\n    /** Epoch in seconds for the end of the availability period */\n    period_end: number;\n    /** Whether to include cancelled events in the returned list */\n    include_cancelled?: boolean;\n}\n\nexport interface CalendarEventShowParams {\n    /** ID of the personal calendar to grab the events details from */\n    calendar?: string;\n    /** ID of the system/space to get the associated calendar ID */\n    system_id?: string;\n}\n\nconst EVENTS_ENDPOINT = `/api/staff/v1/events`;\n\n/**\n * List events\n * @param q Parameters to pass to the API request\n */\nexport function queryEvents(\n    q: CalendarEventQueryParams\n): Observable<CalendarEvent[]> {\n    const query = toQueryString(q);\n    return get(`${EVENTS_ENDPOINT}${query ? '?' + query : ''}`).pipe(\n        map((list) => list.map((e) => new CalendarEvent(e)))\n    );\n}\n\n/**\n * Get event details\n * @param id ID of the event to grab\n * @param q Parameters to pass to the API request\n */\nexport function showEvent(id: string, q: CalendarEventShowParams = {}) {\n    const query = toQueryString(q);\n    return get(`${EVENTS_ENDPOINT}/${encodeURIComponent(id)}${query ? '?' + query : ''}`).pipe(\n        map((item) => new CalendarEvent(item))\n    );\n}\n\n/**\n * Create new calendar event and add it to the database\n * @param data New calendar event fields\n */\nexport function createEvent(data: Partial<CalendarEvent>) {\n    return post(`${EVENTS_ENDPOINT}`, data).pipe(\n        map((item) => new CalendarEvent(item))\n    );\n}\n\n/**\n * Update an existing calendar event\n * @param id ID of the event to update\n * @param data New values for event fields\n * @param q Parameters to pass to the API request\n * @param method HTTP verb to use with API request\n */\nexport function updateEvent(\n    id: string,\n    data: Partial<CalendarEvent>,\n    q: CalendarEventShowParams = {},\n    method: 'put' | 'patch' = 'patch'\n) {\n    const query = toQueryString(q);\n    return (method === 'patch' ? patch : put)(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}${query ? '?' + query : ''}`,\n        data\n    ).pipe(map((item) => new CalendarEvent(item)));\n}\n\n/**\n * Save changes to or create a calendar event\n * @param data State of the calendar event\n * @param q Parameters to pass to the API request\n */\nexport const saveEvent = (\n    data: Partial<CalendarEvent>,\n    q?: CalendarEventShowParams\n) => (data.id ? updateEvent(data.id, data, q) : createEvent(data));\n\n/**\n * Remove calendar event from the database\n * @param id ID of the event to remove\n * @param q Parameters to pass to the API request\n */\nexport function removeEvent(id: string, q: CalendarEventShowParams = {}) {\n    const query = toQueryString(q);\n    return del(`${EVENTS_ENDPOINT}/${encodeURIComponent(id)}${query ? '?' + query : ''}`, {\n        response_type: 'void',\n    });\n}\n\n/**\n * Set the approval state of the event to approved\n * @param id ID of the event to approve\n * @param system_id Associated system to approve\n */\nexport function approveEvent(id: string, system_id: string) {\n    return post(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}/approve?system_id=${encodeURIComponent(\n            system_id\n        )}`,\n        ''\n    ).pipe(map((item) => new CalendarEvent(item)));\n}\n\n/**\n * Set the approval state of the event to rejected\n * @param id ID of the event to reject\n * @param system_id Associated system to reject\n */\nexport function rejectEvent(id: string, system_id: string) {\n    return post(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}/reject?system_id=${encodeURIComponent(\n            system_id\n        )}`,\n        ''\n    ).pipe(map((item) => new CalendarEvent(item)));\n}\n\n/**\n * List guests for event\n * @param id ID of the event to grab\n * @param q Parameters to pass to the API request\n */\nexport function queryEventGuests(\n    id: string,\n    q: CalendarEventShowParams = {}\n): Observable<GuestUser[]> {\n    const query = toQueryString(q);\n    return get(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}/guests${query ? '?' + query : ''}`\n    ).pipe(map((list) => list.map((item) => new GuestUser(item))));\n}\n\n/**\n * Set the checkin state of an event guest\n * @param id ID of the event to grab\n * @param guest_id ID of the guest to update\n * @param state New checkin state of the guest\n * @param q Parameters to pass to the API request\n */\nexport function checkinEventGuest(\n    id: string,\n    guest_id: string,\n    state: boolean,\n    q: CalendarEventShowParams = {}\n) {\n    const query = toQueryString({ ...q, state });\n    return get(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}/guests/${guest_id}${query ? '?' + query : ''}`\n    ).pipe(map((item) => new GuestUser(item)));\n}\n"],"sourceRoot":"webpack:///"}