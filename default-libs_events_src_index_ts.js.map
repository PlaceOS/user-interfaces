{"version":3,"sources":["./libs/calendar/src/lib/calendar.class.ts","./libs/calendar/src/lib/calendar.fn.ts","./libs/events/src/lib/events.fn.ts","./libs/events/src/lib/validators.ts","./libs/events/src/lib/utilities.ts","./node_modules/date-fns/esm/setMinutes/index.js","./node_modules/date-fns/esm/setHours/index.js"],"names":["Calendar","data","this","id","name","primary","summary","can_edit","resource","system","availability","map","starts_at","ends_at","date","duration","status","Date","valueOf","hidden","CALENDAR_ENDPOINT","calendarsToSpaces","org","list","filter","cal","level","levelWithID","zones","space","bookable","querySpaceAvailability","q","query","pipe","i","c","queryCalendarAvailability","querySpaceFreeBusy","EVENTS_ENDPOINT","showEvent","encodeURIComponent","item","method","toJSON","updateEvent","createEvent","checkinEventGuest","guest_id","state","endInFuture","control","parent","get","isAfter","value","event","form","host","organiser","creator","calendar","attendees","resources","title","body","private","all_day","recurring","recurrence","recurring_master_id","master","attachments","catering","extension_data","visitor_type","ext","location","needs_space","needs_parking","valueChanges","subscribe","o","controls","setValue","email","l","length","disable","add","dirtyDate","dirtyMinutes","requiredArgs","arguments","toDate","minutes","toInteger","setMinutes","dirtyHours","hours","setHours","days"],"mappings":"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","file":"default-libs_events_src_index_ts.js","sourcesContent":["import { differenceInMinutes } from 'date-fns';\n\nimport { Space } from 'libs/spaces/src/lib/space.class';\n\nimport { CalendarAvailability } from './calendar.interfaces';\n\nexport class Calendar {\n    /** ID of the calendar */\n    public readonly id: string;\n    /** Name of the calendar */\n    public readonly name: string;\n    /** System associated with the calendar */\n    public readonly resource: Space;\n    /** Primary calendar of the user */\n    public readonly primary: boolean;\n    /** Summary */\n    public readonly summary: string;\n    /** Whether the user can edit events associated to this calendar */\n    public readonly can_edit: boolean;\n    /** Availability */\n    public readonly availability: CalendarAvailability[];\n    /** Whether calendar should be hidden from the user */\n    public readonly hidden: boolean;\n\n    constructor(data: Partial<Calendar> = {}) {\n        this.id = data.id || '';\n        this.name = data.name || '';\n        this.primary = !!data.primary;\n        this.summary = data.summary || '';\n        this.can_edit = !!data.can_edit;\n        this.resource = new Space(data.resource || (data as any).system);\n        this.availability = (data.availability || []).map(\n            ({ starts_at, ends_at, date, duration, status }: any) => {\n                return {\n                    date: new Date(date, starts_at).valueOf(),\n                    duration:\n                        duration || differenceInMinutes(ends_at, starts_at),\n                    status: status,\n                };\n            }\n        );\n        this.hidden = !!data.hidden;\n    }\n}\n","import { get } from '@placeos/ts-client';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { toQueryString } from '@placeos/common';\nimport { OrganisationService } from '@placeos/organisation';\n\nimport { Space } from 'libs/spaces/src/lib/space.class';\nimport { Calendar } from './calendar.class';\nimport { CalendarAvailabilityQueryParams } from './calendar.interfaces';\n\nconst CALENDAR_ENDPOINT = '/api/staff/v1/calendars';\n\n/** List calendars associated with the logged in user */\nexport function queryCalendars(): Observable<Calendar[]> {\n    return get(CALENDAR_ENDPOINT).pipe(\n        map((i) => i.map((c) => new Calendar(c)))\n    );\n}\n\n/** List room calendars for available spaces based on the given query */\nexport function queryCalendarAvailability(\n    q: CalendarAvailabilityQueryParams\n): Observable<Calendar[]> {\n    const query = toQueryString(q);\n    return get(\n        `${CALENDAR_ENDPOINT}/availability${query ? '?' + query : ''}`\n    ).pipe(map((i) => i.map((c) => new Calendar(c))));\n}\n\nconst calendarsToSpaces = (org?) =>\n    map((list: Calendar[]) =>\n        list\n            .filter((cal) => !!cal.resource)\n            .map(\n                (cal) =>\n                    new Space({\n                        ...cal.resource,\n                        level: org?.levelWithID(cal.resource.zones),\n                        availability: cal.availability,\n                    })\n            )\n            .filter((space) => space.bookable)\n    );\n\n/** List available spaces based on the given query */\nexport function querySpaceAvailability(\n    q: CalendarAvailabilityQueryParams,\n    org?: OrganisationService\n): Observable<Space[]> {\n    return queryCalendarAvailability(q).pipe(calendarsToSpaces(org));\n}\n\n/** List room calendars for available spaces based on the given query */\nexport function querySpaceFreeBusy(\n    q: CalendarAvailabilityQueryParams,\n    org?: OrganisationService\n): Observable<Space[]> {\n    const query = toQueryString(q);\n    return get(\n        `${CALENDAR_ENDPOINT}/free_busy${query ? '?' + query : ''}`\n    ).pipe(\n        map((i) => i.map((c) => new Calendar(c))),\n        calendarsToSpaces(org)\n    );\n}\n","import { del, get, patch, post, put } from '@placeos/ts-client';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { toQueryString } from 'libs/common/src/lib/api';\nimport { GuestUser } from 'libs/users/src/lib/user.class';\n\nimport { CalendarEvent } from './event.class';\n\nexport interface CalendarEventQueryParams {\n    /** Comma seperated list of zone ids to check availability */\n    zone_ids?: string;\n    /** Comma seperated list of system(space) ids to check availability */\n    system_ids?: string;\n    /** Comma seperated list of calendar ids to check availability */\n    calendars?: string;\n    /** Epoch in seconds for the start of the availability period */\n    period_start: number;\n    /** Epoch in seconds for the end of the availability period */\n    period_end: number;\n    /** Whether to include cancelled events in the returned list */\n    include_cancelled?: boolean;\n}\n\nexport interface CalendarEventShowParams {\n    /** ID of the personal calendar to grab the events details from */\n    calendar?: string;\n    /** ID of the system/space to get the associated calendar ID */\n    system_id?: string;\n}\n\nconst EVENTS_ENDPOINT = `/api/staff/v1/events`;\n\n/**\n * List events\n * @param q Parameters to pass to the API request\n */\nexport function queryEvents(\n    q: CalendarEventQueryParams\n): Observable<CalendarEvent[]> {\n    const query = toQueryString(q);\n    return get(`${EVENTS_ENDPOINT}${query ? '?' + query : ''}`).pipe(\n        map((list) => list.map((e) => new CalendarEvent(e)))\n    );\n}\n\n/**\n * Get event details\n * @param id ID of the event to grab\n * @param q Parameters to pass to the API request\n */\nexport function showEvent(id: string, q: CalendarEventShowParams = {}) {\n    const query = toQueryString(q);\n    return get(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}${\n            query ? '?' + query : ''\n        }`\n    ).pipe(map((item) => new CalendarEvent(item)));\n}\n\n/**\n * Create new calendar event and add it to the database\n * @param data New calendar event fields\n */\nexport function createEvent(data: Partial<CalendarEvent>) {\n    return post(`${EVENTS_ENDPOINT}`, new CalendarEvent(data).toJSON()).pipe(\n        map((item) => new CalendarEvent(item))\n    );\n}\n\n/**\n * Update an existing calendar event\n * @param id ID of the event to update\n * @param data New values for event fields\n * @param q Parameters to pass to the API request\n * @param method HTTP verb to use with API request\n */\nexport function updateEvent(\n    id: string,\n    data: Partial<CalendarEvent>,\n    q: CalendarEventShowParams = {},\n    method: 'put' | 'patch' = 'patch'\n) {\n    const query = toQueryString(q);\n    return (method === 'patch' ? patch : put)(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}${\n            query ? '?' + query : ''\n        }`,\n        method === 'patch' ? data : new CalendarEvent(data).toJSON()\n    ).pipe(map((item) => new CalendarEvent(item)));\n}\n\n/**\n * Save changes to or create a calendar event\n * @param data State of the calendar event\n * @param q Parameters to pass to the API request\n */\nexport const saveEvent = (\n    data: Partial<CalendarEvent>,\n    q?: CalendarEventShowParams\n) => {\n    delete (data as any)?.status;\n    return data.id ? updateEvent(data.id, data, q) : createEvent(data);\n};\n\n/**\n * Remove calendar event from the database\n * @param id ID of the event to remove\n * @param q Parameters to pass to the API request\n */\nexport function removeEvent(id: string, q: CalendarEventShowParams = {}) {\n    const query = toQueryString(q);\n    return del(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}${\n            query ? '?' + query : ''\n        }`,\n        {\n            response_type: 'void',\n        }\n    );\n}\n\n/**\n * Set the approval state of the event to approved\n * @param id ID of the event to approve\n * @param system_id Associated system to approve\n */\nexport function approveEvent(id: string, system_id: string) {\n    return post(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(\n            id\n        )}/approve?system_id=${encodeURIComponent(system_id)}`,\n        ''\n    ).pipe(map((item) => new CalendarEvent(item)));\n}\n\n/**\n * Set the approval state of the event to rejected\n * @param id ID of the event to reject\n * @param system_id Associated system to reject\n */\nexport function rejectEvent(id: string, system_id: string) {\n    return post(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(\n            id\n        )}/reject?system_id=${encodeURIComponent(system_id)}`,\n        ''\n    ).pipe(map((item) => new CalendarEvent(item)));\n}\n\n/**\n * List guests for event\n * @param id ID of the event to grab\n * @param q Parameters to pass to the API request\n */\nexport function queryEventGuests(\n    id: string,\n    q: CalendarEventShowParams = {}\n): Observable<GuestUser[]> {\n    const query = toQueryString(q);\n    return get(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(id)}/guests${\n            query ? '?' + query : ''\n        }`\n    ).pipe(map((list) => list.map((item) => new GuestUser(item))));\n}\n\n/**\n * Set the checkin state of an event guest\n * @param id ID of the event to grab\n * @param guest_id ID of the guest to update\n * @param state New checkin state of the guest\n * @param q Parameters to pass to the API request\n */\nexport function checkinEventGuest(\n    id: string,\n    guest_id: string,\n    state: boolean,\n    q: CalendarEventShowParams = {}\n) {\n    const query = toQueryString({ ...q, state });\n    return post(\n        `${EVENTS_ENDPOINT}/${encodeURIComponent(\n            id\n        )}/guests/${guest_id}/checkin${query ? '?' + query : ''}`,\n        ''\n    ).pipe(map((item) => new GuestUser(item)));\n}\n","import { AbstractControl } from '@angular/forms';\nimport { addMinutes, isAfter, isBefore } from 'date-fns';\n\nexport const endInFuture = (control: AbstractControl) => {\n    if (\n        control.parent?.get('date') &&\n        isAfter(\n            new Date(),\n            addMinutes(control.parent.get('date').value, control.value)\n        )\n    ) {\n        return { duration: true };\n    }\n    return null;\n};\n\n/** Check that date in unix ms is in the future */\nexport function isFuture(\n    control: AbstractControl\n): { [key: string]: boolean } | null {\n    return control.value && isBefore(control.value, new Date())\n        ? { is_future: true }\n        : null;\n}\n","import { FormGroup, FormControl, Validators } from '@angular/forms';\nimport {\n    add,\n    formatDuration,\n    differenceInMinutes,\n    getTime,\n    isSameDay,\n    format,\n    startOfMinute,\n    setHours,\n    setMinutes,\n    addMinutes,\n} from 'date-fns';\nimport { timePeriodsIntersect, unique } from '@placeos/common';\n\nimport { CalendarEvent } from './event.class';\nimport { endInFuture } from './validators';\nimport { getNextFreeTimeSlot } from './helpers';\n\nlet BOOKING_DATE = add(setMinutes(setHours(new Date(), 6), 0), { days: -1 });\n\nexport function generateEventForm(event: CalendarEvent): FormGroup {\n    const form = new FormGroup({\n        id: new FormControl(event.id),\n        host: new FormControl(event.host || '', [Validators.required]),\n        organiser: new FormControl(event.organiser || {}, [\n            Validators.required,\n        ]),\n        creator: new FormControl(event.creator, [Validators.required]),\n        calendar: new FormControl(event.calendar),\n        attendees: new FormControl(event.attendees || []),\n        resources: new FormControl(event.resources || []),\n        title: new FormControl(event.title, [Validators.required]),\n        body: new FormControl(event.body),\n        private: new FormControl(event.private),\n        date: new FormControl(event.date, [Validators.required]),\n        duration: new FormControl(event.duration, [endInFuture]),\n        all_day: new FormControl(event.all_day),\n        recurring: new FormControl(event.recurring),\n        recurrence: new FormControl(event.recurrence),\n        recurring_master_id: new FormControl(event.recurring_master_id),\n        master: new FormControl(event.master),\n        attachments: new FormControl(event.attachments),\n        catering: new FormControl(event.extension_data.catering || []),\n        // has_catering: new FormControl(event.has_catering || false),\n        visitor_type: new FormControl(event.ext('visitor_type')),\n        location: new FormControl(event.location),\n        needs_space: new FormControl(true),\n        needs_parking: new FormControl(event.ext('needs_parking') || false),\n        system: new FormControl(event.system),\n    });\n    form.get('organiser').valueChanges.subscribe((o) =>\n        form.controls.host.setValue(o?.email)\n    );\n    form.get('resources').valueChanges.subscribe((l) =>\n        form.controls.system.setValue(l.length ? l[0] : null)\n    );\n    if (event.id) {\n        form.get('host').disable();\n        form.get('organiser').disable();\n    }\n    if (event.state === 'started') form.get('date').disable();\n    return form;\n}\n\n/**\n * Set the initial time used for generating mock bookings\n * @param time New initial time as ms from UTC epoch\n */\nexport function setMockBookingStartDatetime(time: number) {\n    BOOKING_DATE = startOfMinute(new Date(time));\n}\n\n/**\n * Get current status within bookings\n * @param bookings List of bookings\n * @param host Host of the new event\n * @param date Datetime of the new event\n */\nexport function statusFromBookings(\n    bookings: CalendarEvent[],\n    bookable: boolean,\n    requestable: boolean,\n    date: number = getTime(new Date())\n) {\n    const now = new Date(date);\n    const next_free_slot = getNextFreeTimeSlot(bookings, date, 5);\n    const start = new Date(next_free_slot.start);\n    const end = new Date(next_free_slot.end);\n    const currently_free = timePeriodsIntersect(\n        date,\n        date,\n        next_free_slot.start,\n        next_free_slot.end\n    );\n    const time_until_next_block = formatDuration({\n        minutes: currently_free\n            ? differenceInMinutes(end, now)\n            : differenceInMinutes(start, now),\n    });\n    const free_tomorrow = !currently_free && !isSameDay(start, now);\n    const free_today = currently_free && !isSameDay(end, now);\n    return {\n        status: !bookable\n            ? 'Not Bookable'\n            : currently_free\n            ? requestable\n                ? 'Available by Request'\n                : 'Available'\n            : 'Meeting in Progress',\n        available_until: free_today\n            ? 'No meetings today'\n            : currently_free\n            ? `Free until ${format(end, 'h:mm B')}(${time_until_next_block})`\n            : free_tomorrow\n            ? 'Unavailable today'\n            : `Free at ${format(start, 'h:mm B')}(${time_until_next_block})`,\n    };\n}\n\nexport function replaceBookings(\n    list: CalendarEvent[],\n    new_bookings: CalendarEvent[],\n    filter_options: { space: string; from: number; to: number }\n) {\n    const from = filter_options.from;\n    const to = filter_options.to;\n    const filtered_list = list.filter((booking) => {\n        const start = new Date(booking.date);\n        const end = addMinutes(start, booking.duration);\n        return (\n            !booking.resources.find(\n                (space) => space.email === filter_options.space\n            ) || !timePeriodsIntersect(from, to, start.valueOf(), end.valueOf())\n        );\n    });\n    const updated_list = filtered_list.concat(new_bookings);\n    updated_list.sort((a, b) => a.date - b.date);\n    return unique(updated_list, 'id');\n}\n","import toInteger from \"../_lib/toInteger/index.js\";\nimport toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name setMinutes\n * @category Minute Helpers\n * @summary Set the minutes to the given date.\n *\n * @description\n * Set the minutes to the given date.\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} minutes - the minutes of the new date\n * @returns {Date} the new date with the minutes set\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Set 45 minutes to 1 September 2014 11:30:40:\n * var result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)\n * //=> Mon Sep 01 2014 11:45:40\n */\n\nexport default function setMinutes(dirtyDate, dirtyMinutes) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var minutes = toInteger(dirtyMinutes);\n  date.setMinutes(minutes);\n  return date;\n}","import toInteger from \"../_lib/toInteger/index.js\";\nimport toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name setHours\n * @category Hour Helpers\n * @summary Set the hours to the given date.\n *\n * @description\n * Set the hours to the given date.\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} hours - the hours of the new date\n * @returns {Date} the new date with the hours set\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Set 4 hours to 1 September 2014 11:30:00:\n * var result = setHours(new Date(2014, 8, 1, 11, 30), 4)\n * //=> Mon Sep 01 2014 04:30:00\n */\n\nexport default function setHours(dirtyDate, dirtyHours) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var hours = toInteger(dirtyHours);\n  date.setHours(hours);\n  return date;\n}"],"sourceRoot":"webpack:///"}